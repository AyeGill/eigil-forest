\date{2025-05-03}
\author{eigil-rischel}
\import{macros}
\taxon{Example}
\p{
  Consider the Markov prefibration #{\MAr{\TychDiffStoch} \to \TychDiffStoch}. Equip this with the section #{T(X) = X \otimes X \xto{\pi_0} X} - this described discrete-time systems (whose update is required to be smooth in the input and present state). This is clearly a symmetric monoidal functor and thus defines a systems theory. Note that this is completely different from the ordinary tangent bundle, despite the coincidence of notation.
}
\p{
  Let #{m_1: TS_2 \otimes X_1 \lensto Y_1} and #{m_2: TS_2 \otimes X_2 \lensto Y_2} be two bisystems in this theory.
  As in \ref{efr-SREZ}, we may define a parameterized lens #{(TS_1 \amp TS_2) \otimes (X_1 \oplus X_2) \lensto (Y_1 \oplus X_2)}, denoting by #{\oplus} the coproduct in lenses, and by #{\amp} the Markov structure defined in \ref{efr-FT8J}. Observe that #{TS_1 \amp TS_2} is simply the indexed set #{(S_1 \coprod S_2) \otimes S_1 \otimes S_2 \to S_1\otimes S_2}. There is an obvious indexed map from this to #{T(S_1 \otimes S_2) = S_1 \otimes S_2 \otimes S_1 \otimes S_2}, given by #{(\inl s_1', s_1,s_2) \mapsto (s_1', s_2, s_1, s_2)} and #{(\inr s_2', s_1, s_2) \mapsto (s_1,s_2',s_1,s_2)}. In words, we receive an update either to the #{S}-state or to the #{S'}-state. We apply this update to the relevant state and leave the other alone. This defines a lens #{T(S_1 \otimes S_2) \lensto T(S_1) \amp T(S_2)}, which we may compose with the above to obtain a bisystem #{T(S_1 \otimes S_2) \otimes (X_1 \oplus X_2) \lensto Y_1 \oplus Y_2}. Let us denote this by #{m_1 \oplus m_2}. 
}
\p{
  This has very much the same flavor as the external choice for open games, although we will not develop the theory of this operation in detail here.
}
\p{
  Now, given a smooth (deterministic) map #{F: P \times X \to Y}, where #{P,X,Y} are smooth manifolds (not merely diffeo-toplogical spaces), we obtain a lens #{T^*(F): \arena{T^*P}{P} \otimes \arena{T^*X}{X} \lensto \arena{T^*Y}{Y}}, where #{T^*(-)} denotes the cotangent bundle. (This does not, prima facie, make sense for a general diffeo-topological space).
}
\p{
  Let us take as given some family of lenses #{T(S) = \arena{S \otimes S}{S} \lensto \arena{T^*S}{S}} for various #{S}. Such an operation amounts to choosing a way of updating #{s \in S} given a cotangent vector---hence we can see it as an optimization algorithm. One example of such would be gradient descent, which given a choice of Riemann structure on #{S}, takes a step of a given length in the direction which most quickly decreases the given covector.
}
\p{
  (It should be noted that there are more complicated optimization strategies which don't fit this particular pattern - for example, \em{momentum} algorithms have to maintain some extra internal state other than #{s \in S}. But let's stick with this pattern for this example). Note also that we're not assuming the optimizers are a natural transformation or anything like that.
}
\p{
  Now we are ready to build the neural network architecture known as a generative adversarial network, or GAN (\ref{gan-paper}). Let us first describe the idea. Our goal is to generate additional samples from some distribution, given a set of existing samples---for example, our goal may be to generate more pictures in the same style as an existing corpus. Suppose our data is of type #{X}, and let #{d: I \to X} be the data distribution. We fix some \em{latent distribution} #{\lambda: I \to L}, where #{L} is any space of our choice---usually, #{L} is #{\RR^n} and #{\lambda} is a Gaussian. Finally we choose two neural networks, the \em{generator} #{G: P_G \otimes L \to X}, and the \em{discriminator} #{D: P_D \otimes X \to \RR}. The goal of the discriminator is to discriminate real samples from the data from generated samples, by providing a low value on the generated samples and a high value on the true samples.
}

\p{
  The training process now goes as follows: for each step of training, we either sample from the latent distribution, and have the generator use this to generate a sample, or draw a sample from the data distribution (choosing between these with some probability #{p}). Then in either case, we have the discriminator score the generated sample. If the sample was generated by the generator, the discriminator's loss is equal to its output, otherwise it is equal to #{-1} times its output. We update the discriminator according to the gradient of this loss (minimizing it), and update the generator (if we are in the branch where it was run) according to #the negative of the gradient of this loss with respect to the generator parameters---this amounts to doing a gradient descent update on the generator for the negative of the discriminator loss.
}

\p{
  We can represent this schematically using the following \em{tape diagram} (see \ref{tape-diags-monoidal-monads}):
}

\p{
\figure{
\tex{
  \usepackage{/Users/eigil/Projects/eigil-forest/assets/tikzit}
\usetikzlibrary{backgrounds}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes,shapes.geometric,shapes.misc}
\usepackage{circuitikz}
}{


  % TiKZ style file generated by TikZiT. You may edit this file manually,
% but some things (e.g. comments) may be overwritten. To be readable in
% TikZiT, the only non-comment lines must be of the form:
% \tikzstyle{NAME}=[PROPERTY LIST]

% Node styles
\tikzstyle{System}=[fill=white, draw=black, shape=rectangle, minimum height=1cm]
\tikzstyle{Operation}=[fill=white, draw=black, shape=circle]
\tikzstyle{State}=[fill=white, draw=black, shape=isosceles triangle, shape border rotate=180]
\tikzstyle{ground}=[fill=white, draw=black, shape=ground, rotate=270]

% Edge styles
\tikzstyle{Arrow}=[->]
\tikzstyle{Tape boundary}=[-, draw={rgb,255: red,191; green,0; blue,64}]

\resizebox{\textwidth}{!}{
\begin{tikzpicture}[scale=0.5]
	\begin{pgfonlayer}{nodelayer}
		\node [style=State] (0) at (-5.5, -2.5) {Data};
		\node [style=State] (2) at (-10, 5.25) {Latent};
		\node [style=System] (4) at (-4.5, 5.25) {Generator};
		\node [style=State] (6) at (-4.5, 3) {+1};
		\node [style=State] (7) at (-5.5, -5.25) {-1};
		\node [style=System] (8) at (4.75, 0.25) {};
		\node [style=System] (9) at (4.75, 0.25) {Discriminator};
		\node [style=System] (10) at (9.25, 0.25) {Loss};
		\node [style=none] (11) at (-3.75, 5) {};
		\node [style=none] (12) at (-1.75, 4.75) {};
		\node [style=none] (13) at (1.5, 0.25) {};
		\node [style=none] (14) at (3.25, 0.5) {};
		\node [style=none] (15) at (5, 0) {};
		\node [style=none] (16) at (5, 0.5) {};
		\node [style=none] (17) at (9, 0) {};
		\node [style=none] (18) at (9, 0.5) {};
		\node [style=none] (19) at (6.5, -1) {};
		\node [style=none] (20) at (0.5, -1) {};
		\node [style=none] (21) at (0.5, 0.5) {};
		\node [style=none] (22) at (0.5, 1.25) {};
		\node [style=none] (23) at (3.75, 0) {};
		\node [style=none] (24) at (3.75, 0.5) {};
		\node [style=none] (25) at (9, -0.5) {};
		\node [style=none] (26) at (-3.75, 5.5) {};
		\node [style=none] (27) at (-9.5, 5) {};
		\node [style=none] (29) at (-5.25, 5) {};
		\node [style=none] (30) at (-5.25, 5.5) {};
		\node [style=none] (31) at (-7.5, 5) {};
		\node [style=none] (32) at (-7, 5.5) {};
		\node [style=none] (33) at (-7.5, 5) {};
		\node [style=System] (34) at (-4.5, 8.25) {Optimizer};
		\node [style=none] (35) at (-4.75, 8) {};
		\node [style=none] (36) at (-4.75, 5.5) {};
		\node [style=none] (37) at (-4.75, 6.75) {};
		\node [style=none] (38) at (-4.25, 5.5) {};
		\node [style=none] (39) at (-4.25, 6.75) {};
		\node [style=none] (40) at (-4.25, 8) {};
		\node [style=none] (41) at (4.5, 0.5) {};
		\node [style=System] (42) at (4.75, 3.25) {Optimizer};
		\node [style=none] (43) at (4.5, 3) {};
		\node [style=none] (44) at (4.5, 1.75) {};
		\node [style=none] (45) at (5, 2) {};
		\node [style=none] (46) at (5, 3) {};
		\node [style=none] (47) at (4.5, 3.5) {};
		\node [style=none] (48) at (5, 3.5) {};
		\node [style=none] (49) at (4.5, 7.5) {};
		\node [style=none] (50) at (5, 8) {};
		\node [style=none] (51) at (4.5, 10.25) {};
		\node [style=none] (52) at (5, 10.25) {};
		\node [style=none] (53) at (-4.75, 11.25) {};
		\node [style=none] (54) at (-4.25, 10.75) {};
		\node [style=none] (55) at (-4.75, 13.25) {};
		\node [style=none] (56) at (-4.25, 13.25) {};
		\node [style=none] (57) at (-4.75, 8.5) {};
		\node [style=none] (58) at (-4.25, 8.5) {};
		\node [style=none] (59) at (-2, -0.25) {};
		\node [style=none] (60) at (-15, -0.25) {};
		\node [style=none] (61) at (-10.25, 10) {};
		\node [style=none] (62) at (9.25, 2.75) {};
		\node [style=none] (63) at (1, 8.25) {};
		\node [style=none] (64) at (9, -3.75) {};
		\node [style=none] (65) at (-0.75, -7) {};
		\node [style=none] (66) at (-6.5, -7) {};
		\node [style=none] (67) at (-2, 0.25) {};
		\node [style=none] (68) at (-15, 0.25) {};
		\node [style=none] (69) at (13, -2.25) {};
		\node [style=none] (70) at (13, 1.75) {};
		\node [style=none] (71) at (-15, 1.5) {};
		\node [style=none] (72) at (-15, -1.5) {};
		\node [style=State] (73) at (-16, 0) {Branch};
		\node [style=ground] (74) at (-2.75, -1.5) {};
		\node [style=none] (75) at (-1.25, -1) {};
		\node [style=none] (76) at (-19.25, -1.5) {};
		\node [style=none] (77) at (-19.25, 1.5) {};
		\node [style=ground] (78) at (-7, 5.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=Arrow] (15.center) to (17.center);
		\draw [style=Arrow] (18.center) to (16.center);
		\draw [bend left=45, looseness=0.75] (6) to (20.center);
		\draw [bend right, looseness=1.50] (7) to (20.center);
		\draw [bend left, looseness=1.25] (11.center) to (21.center);
		\draw [bend right, looseness=1.25] (0) to (21.center);
		\draw [style=Arrow] (21.center) to (13.center);
		\draw [style=Arrow] (20.center) to (19.center);
		\draw [style=Arrow, bend right, looseness=1.25] (22.center) to (12.center);
		\draw (22.center) to (14.center);
		\draw (13.center) to (23.center);
		\draw [in=-180, out=0, looseness=1.25] (19.center) to (25.center);
		\draw (12.center) to (26.center);
		\draw [style=Arrow] (27.center) to (33.center);
		\draw [style=Arrow] (30.center) to (32.center);
		\draw (33.center) to (29.center);
		\draw [style=Arrow] (43.center) to (44.center);
		\draw [style=Arrow] (16.center) to (45.center);
		\draw (45.center) to (46.center);
		\draw (44.center) to (41.center);
		\draw [style=Arrow] (48.center) to (50.center);
		\draw [style=Arrow] (51.center) to (49.center);
		\draw (50.center) to (52.center);
		\draw (49.center) to (47.center);
		\draw [style=Arrow] (35.center) to (37.center);
		\draw [style=Arrow] (38.center) to (39.center);
		\draw [style=Arrow] (58.center) to (54.center);
		\draw [style=Arrow] (55.center) to (53.center);
		\draw (53.center) to (57.center);
		\draw (54.center) to (56.center);
		\draw (39.center) to (40.center);
		\draw (37.center) to (36.center);
		\draw [style=Tape boundary] (60.center) to (59.center);
		\draw [style=Tape boundary] (66.center) to (65.center);
		\draw [style=Tape boundary, bend right=15] (65.center) to (64.center);
		\draw [style=Tape boundary] (68.center) to (67.center);
		\draw [style=Tape boundary, bend right=90, looseness=2.25] (59.center) to (67.center);
		\draw [style=Tape boundary, in=150, out=0] (61.center) to (63.center);
		\draw [style=Tape boundary, in=135, out=-30] (63.center) to (62.center);
		\draw [style=Tape boundary, in=-180, out=-30] (62.center) to (70.center);
		\draw [style=Tape boundary, in=-180, out=30] (64.center) to (69.center);
		\draw [style=Tape boundary, bend right=270, looseness=1.75] (60.center) to (68.center);
		\draw [style=Tape boundary, in=0, out=180, looseness=0.75] (66.center) to (72.center);
		\draw [style=Tape boundary, in=0, out=-180, looseness=0.50] (61.center) to (71.center);
		\draw [style=Arrow, bend left=15, looseness=1.75] (22.center) to (75.center);
		\draw [bend left=15] (75.center) to (74);
		\draw [style=Tape boundary] (77.center) to (71.center);
		\draw [style=Tape boundary] (76.center) to (72.center);
		\draw (32.center) to (78);
	\end{pgfonlayer}
\end{tikzpicture}}



}
}
}

\p{
  The two "tapes" branching off at the start represent two maps (bisystems) composed by #{\oplus}, while the backwards wires indicate the flow of the gradients. The ground symbol indicates a value being discarded. Note that the theory of tape diagrams has only been developed formally for \em{distributive} categories, and for essentilly the same reason as in \ref{efr-SREZ}, we do not have distributivity in this case. However, the interpretation of this diagram is still unambiguous---distributivity is required to make tape diagrams \em{complete}, not to make them sound. Concretely, if we tried to represent the tensoring of this system with another system, we would have no way of doing it, but if the category was distributive we could do so by adding this additional system to each of the branches. Still, the figure is best viewed as a visual aid rather than a formal representation.
}