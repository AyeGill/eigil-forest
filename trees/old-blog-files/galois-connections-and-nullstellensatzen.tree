\author{eigil-rischel}
\date{2020-12-09T20:50:00+00:00}
\import{macros}
\title{Galois Connections and Nullstellensatzen}
    \p{
        (The idea for this post is due to [this tweet](https://twitter.com/sarah_zrf/status/1265699700524699650) by @sarah_zrf)
    }
\subtree{
    \title{Hilbert's Nullstellensatz }
    \p{
        Consider the ring of complex polynomials in #{n} variables, #{\mathbb{C}[x_1,x_2,\dots x_n]}. The elements of thing ring can be viewed as _functions_ #{\mathbb{C}^n \to \mathbb{C}}. Given a polynomial #{f}, we can think of it as an _equation_ in #{n} variables - a solution to the equation is a tuple #{(a_1, \dots a_n) \in \mathbb{C}^n} so that #{f(a_1,\dots ,a_n) = 0}. Let #{V(f) \subseteq \mathbb{C}^n} be the set of solutions.
    }
    \p{
        Given a _set_ of polynomials #{S \subset \mathbb{C}[x_1,\dots x_n]}, let #{V(S) = \{(a_1, \dots a_n) \in \mathbb{C}^n \mid f(a_1,\dots a_n) = 0,\ \forall f \in S\}} be the set of solutions to the _system_ of equations given by #{S}.
    }
    \p{
        This gives a mapping from subsets #{S \subset \mathbb{C}[x_1, \dots x_n]} to subsets #{U \subset \mathbb{C}^n}. We can also go the other way - given such an #{U}, let #{I(U)} be the set of #{f} such that #{f(a) = 0} for all #{a \in U}. (We are now writing #{a := (a_1,\dots a_n)} for brevity).
    }
    \p{
        Now #{V} and #{I} enjoy the following very special properties:
    }
    \ul{
        \li{
            They are both _order-reversing_ - if #{U \subseteq U'} then #{I(U') \subseteq I(U)}, and the same for #{V}.
        }
        \li{
            #{S \subseteq I(V(S))} and #{U \subseteq V(I(U))}.
        }
    }
    \p{
        This means that #{I} and #{V} forms a _Galois connection_ ([nlab](https://ncatlab.org/nlab/show/Galois+connection)) - a dual adjunction between two posets. This implies a bunch of interesting things. One of the most important is that the mapping #{S \mapsto I(V(S))} is a _closure operator_, meaning that in addition to the above inequality, #{I(V(I(V(S)))) = I(V(S))}. In fact for anything of the form #{I(U)}, we have #{I(V(I(U))) = I(U)}.
    }
    \p{
        This Galois connection is _the_ key to algebraic geometry. It allows us to analyse algebraic things (subsets of a ring) in geometric terms (subsets of a space). So it would be really good if we could understand this thing. In particular, what is the closure operator #{S \mapsto I(V(S))}?
    }
    \p{
        It's pretty clear that #{I(V(S))} must be an _ideal_ - if #{f(a) = 0} for all #{a \in V(S)}, then #{f(a)g(a) = 0} too (and if #{f(a) = g(a) = 0}, then #{f(a) + g(a) = 0}). So an obvious guess would be that #{I(V(S)) = (S)}, the ideal generated by #{S}.
    }
    \p{
        But this turns out not to be true - there's one more thing we need to close off #{S} under to make this work. Namely, if #{(f^2)(a) = f(a)^2 = 0}, then also #{f(a) = 0}. So if #{f^2 \in I(V(S))}, then #{f \in S} (and similarly for #{f^n}). #{I(V(S))} is a _radical ideal_ - specifically, it is the radical #{\sqrt{(S)}} of the ideal generated by #{S}. This statement is _Hilbert's Nullstellensatz_ ("zero locus theorem", see [wikipedia](https://en.wikipedia.org/wiki/Hilbert\%27s_Nullstellensatz), [nlab](https://ncatlab.org/nlab/show/Nullstellensatz))
    }
}
\subtree{
    \title{Gödel's Nullstellensatz {#gödel-s-nullstellensatz}}
    \p{
        Let #{\mathcal{L}} be a first-order language, i.e a collection of _function symbols_ #{f_1,f_2,\dots}, each with a specified arity, and /relation symbols #{R_1,R_2,\dots}, also each with a specified arity[^fn:1].
    }
    \p{
        An #{\mathcal{L}}-structure is a set #{M} equipped with a function #{[f_i]_M : M^n \to M} for each #{f_i}, where #{n} is the arity of #{f_i}, and a subset #{[R_i]_M \subset M^n} for each #{R_i}, where #{n} is again the arity.
    }
    \p{
        A _first-order formula in #{\mathcal{L}}_ is a formula built up out of the function symbols, variables, and the connectives #{\forall, \exists, \vee, \wedge, \neg, =}. A model #{M} satisfies the formula if the formula is true when interpreted in the usual way for the model.
    }
    \p{
        A _theory_ is a set of formulas. Given a theory #{T}, let #{Sat(T)} be the set of models that satisfy each formula in #{T}. Given a set of models #{\mathcal{M}}, let #{Tru(\mathcal{M})} be the set of formulas that are satisfied by each model.
    }
    \p{
        Then it's not hard to see that #{Sat} and #{Tru} form a Galois connection between sets of formulas (theories), and sets of models. What is the closure operator on theories induced by this Galois connection? In other words: Start with a set of formulas. These formulas pin down a set of models, namely the models that satisfy all those formulas. Now almost certainly some more formulas are going to happen to be true for all these models. For example, if #{\phi \wedge \psi} is a formula in #{T}, then also #{\phi} is going to be true for every model - so #{\phi \in Tru(Sat(T))}. In general, any formula which is _provable_ using the normal rules of logic from formulas in #{T} is going to be in #{Tru(Sat(T))}. This is because the normal rules of logic are _sound_ - if you can prove something from true premises, it's true. And in fact, this suffices! To be precise, #{Tru(Sat(T))} consists _exactly_ of those formulas that are provable using the normal deduction rules of first-order logic from #{T}. This is a celebrated theorem of Gödel ([nlab](https://ncatlab.org/nlab/show/completeness+theorem), [wikipedia](https://en.wikipedia.org/wiki/G\%C3\%B6del\%27s_completeness_theorem)). Since it has the same formal structure as Hilbert's Nullstellensatz - characterizing the closure operator induced by a Galois connection - we might call it _Gödel's Nullstellensatz_. (It is usually called the completeness theorem).
    }
}
\subtree{
    \title{Quillen's Nullstellensatz }
    \p{
        Fix a category #{\mathcal{C}}. Let #{f: X \to Y, g: A \to B} be morphisms. We say that _#{f} has the left lifting property with respect to #{g}_, and that #{g} has the right lifting property with respect to #{f}, if, for each diagram of this form, if the outer square commutes, there exists a dashed arrow making the triangles commute as well:
    }
    \p{
        {{< figure src="/ox-hugo/2020-12-08-local-1.png" >}}
    }
    \p{
        Given a class #{S} of morphisms in #{\mathcal{C}}, let #{LLP(S)} be the class of morphism with the left lifting property with respect to _all_ morphisms #{f \in S}, analogously #{RLP(S)}.
    }
    \p{
        It is again not hard to see that #{RLP} and #{LLP} form a Galois connection from the collection of subclasses of morphisms in #{\mathcal{C}} to itself. What is the closure operator #{LLP(RLP(-))}? This is probably a bit harder to motivate than the previous examples, but understanding it is important in model category theory.
    }
    \p{
        As before, we can try to find some constructions that #{LLP(RLP(-))} is certainly closed under:
    }
    \ul{
        \li{
            Pushouts, in the sense that if #{f: X \to Y} is in #{LLP(RLP(-))}, and #{g: X \to Z} is any morphism, the induced #{Z \to X+_Y Z} is also in there.
        }
        \li{
            Retracts: given a commutative diagram
        }
    }
    \p{
        ![](/ox-hugo/2020-12-08-local-2.png) where the horizontal composites are identities, if #{f} is in the class, so is #{g}
    }
    \ul{
        \li{
            Transfinite composition: given a sequence #{X_0 \to X_1 \to \dots} with each map in the class, the maps to the colimit #{\operatorname{colim}_i X_i} are also in the class (here this diagram can be indexed by any ordinal).
        }
    }
    \p{
        Each of these proofs is essentially by a diagram chase.
    }
    \p{
        A class closed under all these constructions is called _saturated_. Then we have _Quillen's Nullstellensatz_ (which is confusingly usually called the _Small object argument_): If #{\mathcal{C}} is locally presentable, and #{S} is a small set, then #{LLP(RLP(S))} is the smallest saturated class containing #{S}.
    }
    \p{
        [^fn:1]: I guess you can actually dispense with the function symbols if you want
    }
}